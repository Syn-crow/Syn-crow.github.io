<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Algebra Compilator</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>

  <div id="app">
    <h1><b>Algebra Compilator</b></h1>
    <p><b>Authorized characters: "0123456789 +-/x"</b></p>
    <input v-model="code">
    <button v-on:click="compile"><b>compile</b></button>
    <ul id="resultLists">
      <li v-for="(item, i) in resultsLexer.slice().reverse()">
        <p>{{codes.slice().reverse()[i]}}</p>
        <result :result="item"></result>
        <p>{{results.slice().reverse()[i]}}</p>
      </li>
    </ul>'
  </div>


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

<script type="text/javascript">

var app = new Vue({
  el: '#app',
  methods: {
    compile: function(){
      this.codes.push(this.code);
      let lexer = iterate(this.code);
      let error = false;
      lexer.forEach((item, i) => {
        if(item.type=="ERROR" || error){
          error = true;
        }
      });
      this.resultsLexer.push(lexer);
      console.log(error,lexer);
      if(!error){
        this.results.push(parse(lexer)[0].getValue());
      }
    }
  },
  data: {
    code: "",
    message: "",
    results: [],
    resultsLexer:[],
    codes: []
  }
})

// Définition d'un nouveau composant appelé `button-counter`
Vue.component('result', {
  props: ['result'],
  data: function () {
    return {
      count: 0
    }
  },
  template: '<ul class="result"><li v-for="item in result" :class="item.type">{{ item.type }} : {{ item.word}}</li></ul>'
})

function parse(letex){
  let pile = [];
  let i = 0;

  function next(){
    i++;
  }

  function product(duo){

      if(duo.type=="OPERATOR"){
        let b = pile.pop();
        let a = pile.pop();
        if(duo.word =="+") pile.push({"a":a, "b":b, "operator":"+", getValue(){return parseFloat(this.a.getValue()) + parseFloat(this.b.getValue()) }});
        if(duo.word =="-") pile.push({"a":a, "b":b, "operator":"-", getValue(){return this.a.getValue() - this.b.getValue() }});
        if(duo.word =="x" || duo.word == "*") pile.push({"a":a, "b":b, "operator":"x", getValue(){return this.a.getValue() * this.b.getValue() }});
        if(duo.word =="/") pile.push({"a":a, "b":b, "operator":"/", getValue(){return this.a.getValue() / this.b.getValue() }});
      }
      if(duo.type=="NUMBER"){
        console.log("duo:",duo);
        pile.push({"a":duo.word, "b":null, "operator":"null", getValue(){return this.a}});
      }
      if(duo.type=="SYMBOL"){
        let a = pile.pop();
        pile.push({"a":a, "b":null, "operator":"()", getValue(){return this.a.getValue()}});
      }
  }
  function parseA(){
    parseM();
    if(i<letex.length){
    if(letex[i].word=="+"){
      next(); //console.log("nextA1");
      parseA();
      product({"word":"+",type:"OPERATOR"});
    }
    else if(letex[i].word=="-"){
      next();//console.log("nextA2");
      parseA();
      product({"word":"-",type:"OPERATOR"});
    }
    }
  }
  function parseM(){
    parseE();
    if(i<letex.length){
    if(letex[i].word=="x"|| letex[i].word=="*"){
      next();//console.log("nextM1");
      parseM();
      product({"word":"x",type:"OPERATOR"})
    }
    else if(letex[i].word=="/"){
      next();//console.log("nextM2");
      parseM();
      product({"word":"/",type:"OPERATOR"})
    }
    }
  }
  function parseE(){
    if(i<letex.length){
    if(letex[i].word=="("){
      next();//console.log("nextE1");
      parseA();
      console.log("characters juste dans la formule:",letex[i]);
      if(letex[i].word==")"){
        product({"word":"()",type:"SYMBOL"})
        next();
        parseA();
      }
    }
    else if(letex[i].type=="NUMBER"){
      product(letex[i]);
      next();//console.log("nextE2",pile);
    }
    }
  }
  parseA();
  console.log(pile[0].getValue());
  return pile;
}

function iterate(code){

  function consume(){
    word+=src[i];
    i++
  }
  function skip(){
    i++
  }
  function product(type){
    array.push({"type" : type, "word" : word});
    word = "";
  }

  function isNum(){
    let res = "0123456789".includes(src[i])
    if(res){
       consume();
    }
    return res;
  }
  function isNumber(){
    if(!isNum()) return false;
    while(isNum()){

    }product("NUMBER");
    return true;
  }
  function isOperator(){
    let res = "+-/x*".includes(src[i]);
    if(res){
       consume();
       product("OPERATOR");
    }
    return res;
  }
  function isSymbol(){
    let res = "()".includes(src[i]);
    if(res){
       consume();
       product("SYMBOL");
    }
    return res;
  }
  function isNull(){
    let res = " \n".includes(src[i]);
    if(res){
       skip();
    }
    return res;
  }

  let src = code;
  let i =0;
  let word = "";
  let array = [];
  let listTraitement = [isNumber, isNull, isOperator, isSymbol];
  while(src.length>i){
    let n = 0;
    while(!listTraitement[n]()){
      n++;
      if(n>3){
        array.push({type:"ERROR", "word":"character "+ code[i]+ " not reconized"});
        return array;
      }
    }
  }
  return array;
}
</script>

</body>
</html>
